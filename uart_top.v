//
// Module P_components.uart_top.struct
//
// Created:
//          by - dplyzhnik.UNKNOWN 
//          at - 16:03:05 27.07.2020
//
// Generated by Mentor Graphics' HDL Designer(TM) 2018.2 (Build 19)
//

`resetall
`timescale 1ns/10ps
module uart_top #(
   // synopsys template
   parameter stop_tx_crc_mark = 519   // подбирал на глаз что бы 2 последних данных не шли на блок CRC
)
( 
   // Port Declarations
   output  wire           TX, 
   input   wire           RX, 
   input   wire           CLK,            // частота дл€ uarta
   input   wire           RST, 
   input   wire           tx_data_sop, 
   input   wire           tx_data_eop, 
   input   wire    [7:0]  tx_data, 
   input   wire           tx_data_val, 
   output  wire           rx_data_sop, 
   output  wire           rx_data_eop, 
   output  wire           rx_data_val, 
   output  wire           tx_data_ready, 
   output  wire    [7:0]  rx_data, 
   output  wire           rx_data_error, 
   input   wire           rx_data_ready, 
   input   wire           clk_in_fifo,    // частота по записи через avalon
   input   wire           clk_out_fifo,   // частота по чтению через avalon
   output  wire    [3:0]  err_status, 
   input   wire           clk_bit
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire         tx_fifo_full;
wire         tx_fifo_empty;
wire         tx_fifo_wr;
wire  [7:0]  tx_fifo_data;
wire  [9:0]  tx_fifo_wcount;
wire  [7:0]  tx_fifo_data_out;
wire         tx_fifo_rd;
reg          rx_fifo_wr;
wire  [7:0]  rx_data_temp_swap;
wire         rx_fifo_full;
wire         rx_fifo_empty;
wire         rx_data_ready_tmp;
wire  [7:0]  rx_fifo_data_tmp;
wire  [10:0] rx_fifo_wcount;
wire  [15:0] tx_crc_init;
wire  [15:0] tx_crc_xor;
wire  [7:0]  tx_crc_data_in;
wire  [15:0] tx_crc_data_out;
wire         tx_crc_enable;
wire         tx_crc_load;
wire  [7:0]  rx_crc_data_in;
wire  [15:0] rx_crc_data_out;
wire         rx_crc_enable;
wire         rx_crc_load;
wire  [15:0] rx_crc_init;
wire  [15:0] rx_crc_xor;
reg          rcv_enable;


// Instances 
CRC #(8,16,"CRC-16/CCITT","NO","NO") U_2( 
   .DATA_IN (tx_crc_data_in), 
   .CLOCK   (clk_in_fifo), 
   .ACLR    (RST), 
   .LOAD    (tx_crc_load), 
   .ENABLE  (tx_crc_enable), 
   .XOR_OUT (tx_crc_xor), 
   .INIT    (tx_crc_init), 
   .CRC_OUT (tx_crc_data_out)
); 

CRC #(8,16,"CRC-16/CCITT","NO","NO") U_3( 
   .DATA_IN (rx_crc_data_in), 
   .CLOCK   (clk_out_fifo), 
   .ACLR    (RST), 
   .LOAD    (rx_crc_load), 
   .ENABLE  (rx_crc_enable), 
   .XOR_OUT (rx_crc_xor), 
   .INIT    (rx_crc_init), 
   .CRC_OUT (rx_crc_data_out)
); 

uart_1k_fifo U_4( 
   .aclr    (RST), 
   .data    (tx_fifo_data), 
   .rdclk   (clk_bit), 
   .rdreq   (tx_fifo_rd), 
   .wrclk   (clk_in_fifo), 
   .wrreq   (tx_fifo_wr), 
   .q       (tx_fifo_data_out), 
   .rdempty (tx_fifo_empty), 
   .rdusedw (tx_fifo_wcount), 
   .wrfull  (tx_fifo_full), 
   .wrusedw ()
); 

uart_fifo U_1( 
   .aclr    (RST), 
   .data    (rx_data_temp_swap), 
   .rdclk   (clk_out_fifo), 
   .rdreq   (rx_data_ready_tmp), 
   .wrclk   (CLK), 
   .wrreq   (rx_fifo_wr), 
   .q       (rx_fifo_data_tmp), 
   .rdempty (rx_fifo_empty), 
   .rdusedw (rx_fifo_wcount), 
   .wrfull  (rx_fifo_full), 
   .wrusedw ()
); 

// HDL Embedded Text Block 1 TX
// eb1 1   
// объ€вление регистров 
reg tx_data_val_tmp;
reg [7:0] tx_data_tmp;
reg packet_wr_temp;
reg transmit_on;
reg nstop_crc_en;
reg [1:0] wr_crc_cnt;

//===============================================
//        запись по avalon st в фифо
//===============================================
always@(posedge clk_in_fifo,posedge RST) begin
  if(RST) begin
    tx_data_val_tmp   <= 0;
    tx_data_tmp       <= 0;
    packet_wr_temp    <= 0;
    transmit_on       <= 0;
    nstop_crc_en      <= 0;
  end
  else begin
//----------------------------------------
    tx_data_val_tmp   <= tx_data_val;
    tx_data_tmp       <= tx_data;
    
//----------------------------------------
    if(tx_data_sop) packet_wr_temp <= 1;
    if(tx_data_eop) begin  // по тмп работал ранбше
      packet_wr_temp <= 0;
      transmit_on <= 1;
    end   
    else // не было 
    if((tx_fifo_wcount == 0) & (wr_crc_cnt > 1)) transmit_on<= 0;
    else if(tx_fifo_wcount >= stop_tx_crc_mark) nstop_crc_en <= 1;
    else nstop_crc_en <= 0;
  end
end

assign tx_fifo_wr    = (tx_data_val & tx_data_ready) ? 1 : 0 ; // было тмп в вал и реди
assign tx_fifo_data  = tx_data; // было тмп
assign tx_data_ready = ~transmit_on;
//===============================================


//===============================================
//          назначение данных 
//          на вход блока crc
//===============================================

assign tx_crc_data_in = (tx_crc_enable) ? tx_data_tmp : 8'b0;
assign tx_crc_enable = (tx_data_val_tmp & ~nstop_crc_en)| tx_crc_load;
assign tx_crc_load = tx_data_sop;
assign tx_crc_xor = 16'h0000;
assign tx_crc_init = 16'hffff;

wire valid_crc_data_for_packet = ~tx_crc_enable & transmit_on;
wire[7:0] msb_crc = (valid_crc_data_for_packet) ? tx_crc_data_out[15:8]: 8'b0; 
wire[7:0] lsb_crc = (valid_crc_data_for_packet) ? tx_crc_data_out[7:0] : 8'b0;
//===============================================

parameter s_idle   = 4'h0;
parameter s_start  = 4'h1;
parameter s_byte   = 4'h2;
parameter s_stop   = 4'h3;
parameter s_pause  = 4'h4;

reg [7:0] tx_fifo_out_data_tmp;
reg TX_tmp;
reg [3:0] state;
reg [2:0] curr_bit;
reg tx_fifo_read_tmp;

//================================================
//          чтение данных из фифо и формирование
//          последовательного кода TX
//================================================
always@(posedge clk_bit,posedge RST) begin
  if(RST) begin
    tx_fifo_out_data_tmp <= 0;
    TX_tmp <= 1'b1;
    tx_fifo_read_tmp <= 0;
    state <= 0;
    curr_bit <= 0;
    wr_crc_cnt <= 0;
  end
  else begin
    case(state)
      s_idle : begin
                TX_tmp <= 1'b1;
                if(~tx_fifo_empty & ~packet_wr_temp) state <= s_start;
                else state <= s_idle;
      end
      s_start : begin
               tx_fifo_out_data_tmp <= tx_fifo_data_out;
               if(tx_fifo_empty) begin 
                 if(wr_crc_cnt < 2) begin
                    if(wr_crc_cnt == 0) tx_fifo_out_data_tmp <= msb_crc;
                    if(wr_crc_cnt == 1) tx_fifo_out_data_tmp <= lsb_crc;
                    TX_tmp <= 1'b0;
                    state <= s_byte;
                 end
                 else begin 
                  state <= s_idle;
                  wr_crc_cnt <= 0;
                 end
                end
                else begin
                  TX_tmp <= 1'b0;
                  state <= s_byte;
                end
              
      end
      s_byte : begin
               case(curr_bit)
                 3'h0 : begin 
                        TX_tmp <= tx_fifo_out_data_tmp[7];
                        curr_bit <= curr_bit + 1;
                 end
                 3'h1 : begin 
                        TX_tmp <= tx_fifo_out_data_tmp[6];
                        curr_bit <= curr_bit + 1;
                 end
                 3'h2 : begin 
                        TX_tmp <= tx_fifo_out_data_tmp[5];
                        curr_bit <= curr_bit + 1;
                 end
                 3'h3 : begin 
                        TX_tmp <= tx_fifo_out_data_tmp[4];
                        curr_bit <= curr_bit + 1;
                 end
                 3'h4 : begin 
                        TX_tmp <= tx_fifo_out_data_tmp[3];
                        curr_bit <= curr_bit + 1;
                 end
                 3'h5 : begin 
                        TX_tmp <= tx_fifo_out_data_tmp[2];
                        curr_bit <= curr_bit + 1;
                 end
                 3'h6 : begin 
                        TX_tmp <= tx_fifo_out_data_tmp[1];
                        curr_bit <= curr_bit + 1;
                 end
                 3'h7 : begin 
                        TX_tmp <= tx_fifo_out_data_tmp[0];
                        curr_bit <= curr_bit + 1;
                        
                        if(~tx_fifo_empty)tx_fifo_read_tmp <= 1;
                        else tx_fifo_read_tmp <= 0;
                        state <= s_stop;
                 end
               endcase
              
      end
      s_stop : begin
                TX_tmp <= 1'b1;
                tx_fifo_read_tmp <= 0;
                if(tx_fifo_empty) begin
                  if(wr_crc_cnt < 2) begin
                    wr_crc_cnt <= wr_crc_cnt +1;
                    state <= s_start;
                  end
                  else begin
                    wr_crc_cnt <= 0;
                    state <= s_idle;
                  end  
                end 
                else state <= s_start;
      end
      s_pause : begin
                if(tx_fifo_empty) state <= s_idle;
                else state <= s_start;
      end
    endcase
  end
end
//--------------------------------------
//reg rcv_enable; объ€вил в дизайнере
reg [5:0]rcv_enable_cnt;
always@(posedge clk_bit, posedge RST) begin
  if(RST) begin 
    rcv_enable <= 0;
    rcv_enable_cnt <= 0;
  end
  else begin
    if(~transmit_on) begin
      if(rcv_enable_cnt != 16) begin
        rcv_enable_cnt <= rcv_enable_cnt + 1;
        rcv_enable <= 0;
        end
      else begin
        rcv_enable <= 1;
        end
    end
    else begin
      rcv_enable <= 0;
      rcv_enable_cnt <= 0;
    end 
  end
end
//--------------------------------------
assign tx_fifo_rd = tx_fifo_read_tmp;
assign TX = TX_tmp;

//=================================================









// HDL Embedded Text Block 2 RX
// eb2 2 
//   объ€вление регистров и цепей

parameter rx_s_idle   = 4'h0;
parameter rx_s_start  = 4'h1;

parameter rx_s_stop   = 4'h2;


parameter packet0_length = 1282;
parameter packet1_length = 4;
parameter packet2_length = 521;
parameter timeout_treshold = 256; // нужно 16

reg RX_tmp;
reg [15:0] rx_shift_reg;
reg [3:0] state_rx;
reg [7:0] rx_data_temp;
reg [2:0] rcv_bit_counter;
reg frame_error;
reg [10:0] rcv_bait_counter;
reg receive_on;
reg [9:0] timeout_cnt;
reg [2:0] rxLock; 
wire rxOUT;
//=====================================================
//              прием данных по линии RX 
//              и _____ что to еще :)
//=====================================================

always @(posedge CLK) RX_tmp <= RX;

assign rxOUT = (rxLock[0] & rxLock[1]) | (rxLock[0] & rxLock[2]) | (rxLock[1] & rxLock[2]);
always@(posedge CLK, posedge RST) begin // clk_bit
  if(RST) begin
      rxLock <= 3'b111;
  end
  else begin
    //if(rcv_enable) d1 <= RX;
    if(rcv_enable) rxLock <= {RX_tmp,rxLock[2:1]};
    else rxLock <= 3'b111;
  end
end



always @(posedge CLK, posedge RST) begin
  if(RST) rx_shift_reg <= 16'hffff;
  else rx_shift_reg <= {rxOUT,rx_shift_reg[15:1]};
end

reg [4:0] len_cnt;
always @(posedge CLK, posedge RST) begin
  if(RST) begin
    state_rx <= 0;
    rx_data_temp <= 0;
    rcv_bit_counter <= 0;
    frame_error <= 0;
  
    rx_fifo_wr <= 0;
    rcv_bait_counter <= 0;
    receive_on <= 0;
    timeout_cnt <= 0;
    len_cnt <= 0;
  end
  else begin
    case(state_rx)
      rx_s_idle : begin
               if(~rxOUT) begin
                  len_cnt <= len_cnt + 1;
                  if(len_cnt >= 14) begin 
                    state_rx <= rx_s_start;
                    receive_on <= 1;
                    len_cnt <= 0;
                  end
               end 
               else begin 
                  state_rx <= rx_s_idle;//возможно стоит убрать
                  if(receive_on)timeout_cnt <= timeout_cnt + 1;
                  else timeout_cnt <= 0;
               end
               frame_error <= 0;
               rx_fifo_wr <= 0;
               
      end
      rx_s_start : begin
                len_cnt <= len_cnt + 1;
                timeout_cnt <= 0;
                if(len_cnt == 7) rx_data_temp <= {rxOUT,rx_data_temp[7:1]}; //rx_shift_reg
                else if (len_cnt == 15) begin 
                  rcv_bit_counter <= rcv_bit_counter + 1;
                  len_cnt <= 0;
                  end
                if((rcv_bit_counter >= 7) && (len_cnt == 15)) begin 
                  state_rx <= rx_s_stop;
                  len_cnt <= 0;
                end
      end
      rx_s_stop : begin
               if(~rxOUT) begin
                 len_cnt <= len_cnt + 1;
                 if(len_cnt == 15) begin 
                   frame_error <= 1;
                   state_rx <= rx_s_idle;
                   len_cnt <= 0;
                 end
               end  
               else begin
                
                state_rx <= rx_s_idle; //rx_shift_reg
                rx_fifo_wr <= 1;
               rcv_bait_counter <= rcv_bait_counter + 1;
                len_cnt <= 0;
               end
               
      end
     
    endcase
    //-------------------------------------------------
    if(timeout_cnt >= timeout_treshold) begin 
      receive_on <= 0;
      rcv_bait_counter <= 0;
    end
  end
end


assign rx_data_temp_swap = {rx_data_temp[0],rx_data_temp[1],rx_data_temp[2],rx_data_temp[3],rx_data_temp[4],rx_data_temp[5],rx_data_temp[6],rx_data_temp[7]};
//=====================================================
reg rx_data_val_tmp;
reg rx_data_error_tmp;
reg [7:0] rx_fifo_data;
reg reading;
//=====================================================
//                 выдача 
//                по avalon st
//=====================================================
//-----
  reg sync_0,sync_1,sync_2;
  always@(posedge clk_out_fifo,posedge RST) begin
      if(RST) begin
          sync_0 <= 0;
          sync_1 <= 0;
          sync_2 <= 0;
      end
      else begin
        sync_0 <= receive_on;
        sync_1 <= sync_0;
        sync_2 <= sync_0;
      end
  end
//-----

always@(posedge clk_out_fifo, posedge RST) begin
  if(RST) begin
    rx_fifo_data <= 0;
    rx_data_val_tmp <= 0;
    rx_data_error_tmp <= 0;
    reading <= 0;
  end
  else begin
    rx_fifo_data <= rx_fifo_data_tmp;
    if (~sync_2 & ~rx_fifo_empty & rx_data_ready)rx_data_val_tmp <= 1;
    else rx_data_val_tmp <= 0;
    if (rx_data_eop) reading <= 0;
    else if(rx_data_sop) reading <= 1;
    
    
  end
end


assign rx_data_ready_tmp = rx_data_ready & ~sync_2;
assign rx_data_val = rx_data_val_tmp;
assign rx_data_sop = ~reading & rx_data_val_tmp & ~sync_2; 
assign rx_data_eop = (rx_data_val_tmp & ~sync_2 & (rx_fifo_wcount == 1)) ? 1 : 0;
assign rx_data = rx_fifo_data;
assign rx_data_error = rx_data_error_tmp;
//================================================
//
reg packet_for_crc; 

wire packet_for_crc_temp = ~reading & ~sync_2 & ((rx_fifo_wcount == packet1_length) | (rx_fifo_wcount == packet0_length) | (rx_fifo_wcount == packet2_length));//добавил 3й пакет тестовый
assign rx_crc_load = rx_data_ready_tmp & ~rx_data_val_tmp & ~rx_fifo_empty & packet_for_crc_temp ; // packet_for_crc добавл€ю 
assign rx_crc_enable = (rx_data_val_tmp & packet_for_crc & (rx_fifo_wcount >= 3)) | rx_crc_load;
assign rx_crc_data_in = (rx_crc_enable)? rx_fifo_data : 8'b0;
assign rx_crc_xor = 16'h0000;
assign rx_crc_init = 16'hffff;
wire packet_id;


always@(posedge clk_out_fifo, posedge RST) begin
  if(RST) packet_for_crc <= 0;
  else if(~sync_2) begin
    if(packet_for_crc_temp) packet_for_crc <= 1;
  end
  else packet_for_crc <= 0;
end

wire crc_error; 
reg size_error;
reg [15:0] got_crc, calc_crc;
reg packet_id2;

always@(posedge clk_out_fifo,posedge RST) begin //сменю частоту с CLK на clk_out_fifo
  if(RST) begin
    got_crc <= 0;
    size_error <= 0;
    calc_crc <= 0;
  end
  else begin 
    if(packet_for_crc) begin
      if (rx_fifo_wcount == 3) got_crc[15:8] <= rx_fifo_data_tmp; // не тмп
      else if(rx_fifo_wcount == 2) got_crc[7:0] <= rx_fifo_data_tmp;
      if(~packet_for_crc_temp & ~rx_crc_enable) calc_crc <= rx_crc_data_out; 
    end 
    else begin
      got_crc <= 0; 
      calc_crc <= 0;
    end
    if (rx_fifo_wcount == 16'h5) //& rx_fifo_wcount < packet0_length - 16'h5 )  
      packet_id2 <= 1; 
    else  
      packet_id2 <= 0;
    
    //----
    if(~sync_2 & ~reading & ~rx_fifo_empty) begin
      if((rx_fifo_wcount != packet0_length) & (rx_fifo_wcount != packet1_length) & (rx_fifo_wcount != packet2_length)) size_error <= 1;
    end
    else size_error <= 0;
  end  
end 
 
//=====================================================
assign crc_error = (rx_data_eop & (calc_crc != got_crc)) ? 1 : 0;
assign err_status[3:0] = {packet_id2,frame_error,crc_error,size_error};

















// HDL Embedded Text Block 3 eb1
//// eb1 3                                        
//assign crc_data_in = (tx_crc_enable) ? tx_crc_data_in : 8'hz;
//assign crc_data_in = (rx_crc_enable) ? rx_crc_data_in : 8'hz;
//assign crc_load = tx_crc_load | rx_crc_load;
//assign crc_enable = tx_crc_enable | rx_crc_enable;
//




endmodule // uart_top

